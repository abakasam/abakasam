/home/cabox/workspace/abakasam/scripts/code/...code
/home/cabox/workspace/desktop/ionic/iojs-3.3.1/lib/_debugger.js
0 'use strict';
1
2 const util = require('util');
3 const path = require('path');
4 const net = require('net');
5 const vm = require('vm');
6 const Module = require('module');
7 const repl = Module.requireRepl();
8 const inherits = util.inherits;
9 const assert = require('assert');
10 const spawn = require('child_process').spawn;
11 const Buffer = require('buffer').Buffer;
12
13 exports.start = function(argv, stdin, stdout) {
14 argv || (argv = process.argv.slice(2));
15
16 if (argv.length < 1) {
17 console.error('Usage: iojs debug script.js');
18 console.error(' iojs debug <host>:<port>');
19 console.error(' iojs debug -p <pid>');
20 process.exit(1);
21 }
22
23 // Setup input/output streams
24 stdin = stdin || process.stdin;
25 stdout = stdout || process.stdout;
26
27 var args = ['--debug-brk'].concat(argv),
28 interface_ = new Interface(stdin, stdout, args);
29
30 stdin.resume();
31
32 process.on('uncaughtException', function(e) {
33 console.error("There was an internal error in Node's debugger. " +
34 'Please report this bug.');
35 console.error(e.message);
36 console.error(e.stack);
37 if (interface_.child) interface_.child.kill();
38 process.exit(1);
39 });
40 };
41
42 exports.port = 5858;
43
44
45 //
46 // Parser/Serializer for V8 debugger protocol
47 // http://code.google.com/p/v8/wiki/DebuggerProtocol
48 //
49 // Usage:
50 // p = new Protocol();
51 //
52 // p.onResponse = function(res) {
53 // // do stuff with response from V8
54 // };
55 //
56 // socket.setEncoding('utf8');
57 // socket.on('data', function(s) {
58 // // Pass strings into the protocol
59 // p.execute(s);
60 // });
61 //
62 //
63 function Protocol() {
64 this._newRes();
65 }
66 exports.Protocol = Protocol;
67
68
69 Protocol.prototype._newRes = function(raw) {
70 this.res = { raw: raw || '', headers: {} };
71 this.state = 'headers';
72 this.reqSeq = 1;
73 this.execute('');
74 };
75
76
77 Protocol.prototype.execute = function(d) {
78 var res = this.res;
79 res.raw += d;
80
81 switch (this.state) {
82 case 'headers':
83 var endHeaderIndex = res.raw.indexOf('rnrn');
84
85 if (endHeaderIndex < 0) break;
86
87 var rawHeader = res.raw.slice(0, endHeaderIndex);
88 var endHeaderByteIndex = Buffer.byteLength(rawHeader, 'utf8');
89 var lines = rawHeader.split('rn');
90 for (var i = 0; i < lines.length; i++) {
91 var kv = lines[i].split(/: +/);
92 res.headers[kv[0]] = kv[1];
93 }
94
95 this.contentLength = +res.headers['Content-Length'];
96 this.bodyStartByteIndex = endHeaderByteIndex + 4;
97
98 this.state = 'body';
99
100 var len = Buffer.byteLength(res.raw, 'utf8');
101 if (len - this.bodyStartByteIndex < this.contentLength) {
102 break;
103 }
104 // falls through
105 case 'body':
106 var resRawByteLength = Buffer.byteLength(res.raw, 'utf8');
107
108 if (resRawByteLength - this.bodyStartByteIndex >= this.contentLength) {
109 var buf = new Buffer(resRawByteLength);
110 buf.write(res.raw, 0, resRawByteLength, 'utf8');
111 res.body =
112 buf.slice(this.bodyStartByteIndex,
113 this.bodyStartByteIndex +
114 this.contentLength).toString('utf8');
115 // JSON parse body?
116 res.body = res.body.length ? JSON.parse(res.body) : {};
117
118 // Done!
119 this.onResponse(res);
120
121 this._newRes(buf.slice(this.bodyStartByteIndex +
122 this.contentLength).toString('utf8'));
123 }
124 break;
125
126 default:
127 throw new Error('Unknown state');
128 }
129 };
130
131
132 Protocol.prototype.serialize = function(req) {
133 req.type = 'request';
134 req.seq = this.reqSeq++;
135 var json = JSON.stringify(req);
136 return 'Content-Length: ' + Buffer.byteLength(json, 'utf8') +
137 'rnrn' + json;
138 };
139
140
141 const NO_FRAME = -1;
142
143 function Client() {
144 net.Stream.call(this);
145 var protocol = this.protocol = new Protocol(this);
146 this._reqCallbacks = [];
147 var socket = this;
148
149 this.currentFrame = NO_FRAME;
150 this.currentSourceLine = -1;
151 this.handles = {};
152 this.scripts = {};
153 this.breakpoints = [];
154
155 // Note that 'Protocol' requires strings instead of Buffers.
156 socket.setEncoding('utf8');
157 socket.on('data', function(d) {
158 protocol.execute(d);
159 });
160
161 protocol.onResponse = this._onResponse.bind(this);
162 }
163 inherits(Client, net.Stream);
164 exports.Client = Client;
165
166
167 Client.prototype._addHandle = function(desc) {
168 if (desc === null || typeof desc !== 'object' ||
169 typeof desc.handle !== 'number') {
170 return;
171 }
172
173 this.handles[desc.handle] = desc;
174
175 if (desc.type === 'script') {
176 this._addScript(desc);
177 }
178 };
179
180
181 const natives = process.binding('natives');
182
183
184 Client.prototype._addScript = function(desc) {
185 this.scripts[desc.id] = desc;
186 if (desc.name) {
187 desc.isNative = (desc.name.replace('.js', '') in natives) ||
188 desc.name == 'node.js';
189 }
190 };
191
192
193 Client.prototype._removeScript = function(desc) {
194 this.scripts[desc.id] = undefined;
195 };
196
197
198 Client.prototype._onResponse = function(res) {
199 var cb,
200 index = -1;
201
202 this._reqCallbacks.some(function(fn, i) {
203 if (fn.request_seq == res.body.request_seq) {
204 cb = fn;
205 index = i;
206 return true;
207 }
208 });
209
210 var self = this;
211 var handled = false;
212
213 if (res.headers.Type == 'connect') {
214 // Request a list of scripts for our own storage.
215 self.reqScripts();
216 self.emit('ready');
217 handled = true;
218
219 } else if (res.body && res.body.event == 'break') {
220 this.emit('break', res.body);
221 handled = true;
222
223 } else if (res.body && res.body.event == 'exception') {
224 this.emit('exception', res.body);
225 handled = true;
226
227 } else if (res.body && res.body.event == 'afterCompile') {
228 this._addHandle(res.body.body.script);
229 handled = true;
230
231 } else if (res.body && res.body.event == 'scriptCollected') {
232 // ???
233 this._removeScript(res.body.body.script);
234 handled = true;
235
236 } else if (res.body && res.body.event === 'compileError') {
237 // This event is not used anywhere right now, perhaps somewhere in the
238 // future?
239 handled = true;
240 }
241
242 if (cb) {
243 this._reqCallbacks.splice(index, 1);
244 handled = true;
245
246 var err = res.success === false && (res.message || true) ||
247 res.body.success === false && (res.body.message || true);
248 cb(err, res.body && res.body.body || res.body, res);
249 }
250
251 if (!handled) this.emit('unhandledResponse', res.body);
252 };
253
254
255 Client.prototype.req = function(req, cb) {
256 this.write(this.protocol.serialize(req));
257 cb.request_seq = req.seq;
258 this._reqCallbacks.push(cb);
259 };
260
261
262 Client.prototype.reqVersion = function(cb) {
263 cb = cb || function() {};
264 this.req({ command: 'version' }, function(err, body, res) {
265 if (err) return cb(err);
266 cb(null, res.body.body.V8Version, res.body.running);
267 });
268 };
269
270
271 Client.prototype.reqLookup = function(refs, cb) {
272 var self = this;
273
274 // TODO: We have a cache of handle's we've already seen in this.handles
275 // This can be used if we're careful.
276 var req = {
277 command: 'lookup',
278 arguments: {
279 handles: refs
280 }
281 };
282
283 cb = cb || function() {};
284 this.req(req, function(err, res) {
285 if (err) return cb(err);
286 for (var ref in res) {
287 if (res[ref] !== null && typeof res[ref] === 'object') {
288 self._addHandle(res[ref]);
289 }
290 }
291
292 cb(null, res);
293 });
294 };
295
296 Client.prototype.reqScopes = function(cb) {
297 var self = this,
298 req = {
299 command: 'scopes',
300 arguments: {}
301 };
302
303 cb = cb || function() {};
304 this.req(req, function(err, res) {
305 if (err) return cb(err);
306 var refs = res.scopes.map(function(scope) {
307 return scope.object.ref;
308 });
309
310 self.reqLookup(refs, function(err, res) {
311 if (err) return cb(err);
312
313 var globals = Object.keys(res).map(function(key) {
314 return res[key].properties.map(function(prop) {
315 return prop.name;
316 });
317 });
318
319 cb(null, globals.reverse());
320 });
321 });
322 };
323
324 // This is like reqEval, except it will look up the expression in each of the
325 // scopes associated with the current frame.
326 Client.prototype.reqEval = function(expression, cb) {
327 var self = this;
328
329 if (this.currentFrame == NO_FRAME) {
330 // Only need to eval in global scope.
331 this.reqFrameEval(expression, NO_FRAME, cb);
332 return;
333 }
334
335 cb = cb || function() {};
336 // Otherwise we need to get the current frame to see which scopes it has.
337 this.reqBacktrace(function(err, bt) {
338 if (err || !bt.frames) {
339 // ??
340 return cb(null, {});
341 }
342
343 var frame = bt.frames[self.currentFrame];
344
345 var evalFrames = frame.scopes.map(function(s) {
346 if (!s) return;
347 var x = bt.frames[s.index];
348 if (!x) return;
349 return x.index;
350 });
351
352 self._reqFramesEval(expression, evalFrames, cb);
353 });
354 };
355
356
357 // Finds the first scope in the array in which the expression evals.
358 Client.prototype._reqFramesEval = function(expression, evalFrames, cb) {
359 if (evalFrames.length == 0) {
360 // Just eval in global scope.
361 this.reqFrameEval(expression, NO_FRAME, cb);
362 return;
363 }
364
365 var self = this;
366 var i = evalFrames.shift();
367
368 cb = cb || function() {};
369 this.reqFrameEval(expression, i, function(err, res) {
370 if (!err) return cb(null, res);
371 self._reqFramesEval(expression, evalFrames, cb);
372 });
373 };
374
375
376 Client.prototype.reqFrameEval = function(expression, frame, cb) {
377 var self = this;
378 var req = {
379 command: 'evaluate',
380 arguments: { expression: expression }
381 };
382
383 if (frame == NO_FRAME) {
384 req.arguments.global = true;
385 } else {
386 req.arguments.frame = frame;
387 }
388
389 cb = cb || function() {};
390 this.req(req, function(err, res) {
391 if (!err) self._addHandle(res);
392 cb(err, res);
393 });
394 };
395
396
397 // reqBacktrace(cb)
398 // TODO: from, to, bottom
399 Client.prototype.reqBacktrace = function(cb) {
400 this.req({ command: 'backtrace', arguments: { inlineRefs: true } }, cb);
401 };
402
403
404 // reqSetExceptionBreak(type, cb)
405 // TODO: from, to, bottom
406 Client.prototype.reqSetExceptionBreak = function(type, cb) {
407 this.req({
408 command: 'setexceptionbreak',
409 arguments: { type: type, enabled: true }
410 }, cb);
411 };
412
413
414 // Returns an array of objects like this:
415 //
416 // { handle: 11,
417 // type: 'script',
418 // name: 'node.js',
419 // id: 14,
420 // lineOffset: 0,
421 // columnOffset: 0,
422 // lineCount: 562,
423 // sourceStart: '(function(process) {nn ',
424 // sourceLength: 15939,
425 // scriptType: 2,
426 // compilationType: 0,
427 // context: { ref: 10 },
428 // text: 'node.js (lines: 562)' }
429 //
430 Client.prototype.reqScripts = function(cb) {
431 var self = this;
432 cb = cb || function() {};
433
434 this.req({ command: 'scripts' }, function(err, res) {
435 if (err) return cb(err);
436
437 for (var i = 0; i < res.length; i++) {
438 self._addHandle(res[i]);
439 }
440 cb(null);
441 });
442 };
443
444
445 Client.prototype.reqContinue = function(cb) {
446 this.currentFrame = NO_FRAME;
447 this.req({ command: 'continue' }, cb);
448 };
449
450 Client.prototype.listbreakpoints = function(cb) {
451 this.req({ command: 'listbreakpoints' }, cb);
452 };
453
454 Client.prototype.setBreakpoint = function(req, cb) {
455 req = {
456 command: 'setbreakpoint',
457 arguments: req
458 };
459
460 this.req(req, cb);
461 };
462
463 Client.prototype.clearBreakpoint = function(req, cb) {
464 var req = {
465 command: 'clearbreakpoint',
466 arguments: req
467 };
468
469 this.req(req, cb);
470 };
471
472 Client.prototype.reqSource = function(from, to, cb) {
473 var req = {
474 command: 'source',
475 fromLine: from,
476 toLine: to
477 };
478
479 this.req(req, cb);
480 };
481
482
483 // client.next(1, cb);
484 Client.prototype.step = function(action, count, cb) {
485 var req = {
486 command: 'continue',
487 arguments: { stepaction: action, stepcount: count }
488 };
489
490 this.currentFrame = NO_FRAME;
491 this.req(req, cb);
492 };
493
494
495 Client.prototype.mirrorObject = function(handle, depth, cb) {
496 var self = this;
497
498 var val;
499
500 if (handle.type === 'object') {
501 // The handle looks something like this:
502 // { handle: 8,
503 // type: 'object',
504 // className: 'Object',
505 // constructorFunction: { ref: 9 },
506 // protoObject: { ref: 4 },
507 // prototypeObject: { ref: 2 },
508 // properties: [ { name: 'hello', propertyType: 1, ref: 10 } ],
509 // text: '#<an Object>' }
510
511 // For now ignore the className and constructor and prototype.
512 // TJ's method of object inspection would probably be good for this:
513 // https://groups.google.com/forum/?pli=1#!topic/nodejs-dev/4gkWBOimiOg
514
515 var propertyRefs = handle.properties.map(function(p) {
516 return p.ref;
517 });
518
519 cb = cb || function() {};
520 this.reqLookup(propertyRefs, function(err, res) {
521 if (err) {
522 console.error('problem with reqLookup');
523 cb(null, handle);
524 return;
525 }
526
527 var mirror,
528 waiting = 1;
529
530 if (handle.className == 'Array') {
531 mirror = [];
532 } else if (handle.className == 'Date') {
533 mirror = new Date(handle.value);
534 } else {
535 mirror = {};
536 }
537
538
539 var keyValues = [];
540 handle.properties.forEach(function(prop, i) {
541 var value = res[prop.ref];
542 var mirrorValue;
543 if (value) {
544 mirrorValue = value.value ? value.value : value.text;
545 } else {
546 mirrorValue = '[?]';
547 }
548
549 if (Array.isArray(mirror) && typeof prop.name !== 'number') {
550 // Skip the 'length' property.
551 return;
552 }
553
554 keyValues[i] = {
555 name: prop.name,
556 value: mirrorValue
557 };
558 if (value && value.handle && depth > 0) {
559 waiting++;
560 self.mirrorObject(value, depth - 1, function(err, result) {
561 if (!err) keyValues[i].value = result;
562 waitForOthers();
563 });
564 }
565 });
566
567 waitForOthers();
568 function waitForOthers() {
569 if (--waiting === 0 && cb) {
570 keyValues.forEach(function(kv) {
571 mirror[kv.name] = kv.value;
572 });
573 cb(null, mirror);
574 }
575 };
576 });
577 return;
578 } else if (handle.type === 'function') {
579 val = function() {};
580 } else if (handle.type === 'null') {
581 val = null;
582 } else if (handle.value !== undefined) {
583 val = handle.value;
584 } else if (handle.type === 'undefined') {
585 val = undefined;
586 } else {
587 val = handle;
588 }
589 process.nextTick(cb, null, val);
590 };
591
592
593 Client.prototype.fullTrace = function(cb) {
594 var self = this;
595
596 cb = cb || function() {};
597 this.reqBacktrace(function(err, trace) {
598 if (err) return cb(err);
599 if (trace.totalFrames <= 0) return cb(Error('No frames'));
600
601 var refs = [];
602
603 for (var i = 0; i < trace.frames.length; i++) {
604 var frame = trace.frames[i];
605 // looks like this:
606 // { type: 'frame',
607 // index: 0,
608 // receiver: { ref: 1 },
609 // func: { ref: 0 },
610 // script: { ref: 7 },
611 // constructCall: false,
612 // atReturn: false,
613 // debuggerFrame: false,
614 // arguments: [],
615 // locals: [],
616 // position: 160,
617 // line: 7,
618 // column: 2,
619 // sourceLineText: ' debugger;',
620 // scopes: [ { type: 1, index: 0 }, { type: 0, index: 1 } ],
621 // text: '#00 blah() /home/ryan/projects/node/test-debug.js l...' }
622 refs.push(frame.script.ref);
623 refs.push(frame.func.ref);
624 refs.push(frame.receiver.ref);
625 }
626
627 self.reqLookup(refs, function(err, res) {
628 if (err) return cb(err);
629
630 for (var i = 0; i < trace.frames.length; i++) {
631 var frame = trace.frames[i];
632 frame.script = res[frame.script.ref];
633 frame.func = res[frame.func.ref];
634 frame.receiver = res[frame.receiver.ref];
635 }
636
637 cb(null, trace);
638 });
639 });
640 };
641
642
643 const commands = [
644 [
645 'run (r)',
646 'cont (c)',
647 'next (n)',
648 'step (s)',
649 'out (o)',
650 'backtrace (bt)',
651 'setBreakpoint (sb)',
652 'clearBreakpoint (cb)'
653 ],
654 [
655 'watch',
656 'unwatch',
657 'watchers',
658 'repl',
659 'restart',
660 'kill',
661 'list',
662 'scripts',
663 'breakOnException',
664 'breakpoints',
665 'version'
666 ]
667 ];
668
669
670 var helpMessage = 'Commands: ' + commands.map(function(group) {
671 return group.join(', ');
672 }).join(',n');
673
674
675 function SourceUnderline(sourceText, position, repl) {
676 if (!sourceText) return '';
677
678 var head = sourceText.slice(0, position),
679 tail = sourceText.slice(position);
680
681 // Colourize char if stdout supports colours
682 if (repl.useColors) {
683 tail = tail.replace(/(.+?)([^w]|$)/, 'u001b[32m$1u001b[39m$2');
684 }
685
686 // Return source line with coloured char at `position`
687 return [
688 head,
689 tail
690 ].join('');
691 }
692
693
694 function SourceInfo(body) {
695 var result = body.exception ? 'exception in ' : 'break in ';
696
697 if (body.script) {
698 if (body.script.name) {
699 var name = body.script.name,
700 dir = path.resolve() + '/';
701
702 // Change path to relative, if possible
703 if (name.indexOf(dir) === 0) {
704 name = name.slice(dir.length);
705 }
706
707 result += name;
708 } else {
709 result += '[unnamed]';
710 }
711 }
712 result += ':';
713 result += body.sourceLine + 1;
714
715 if (body.exception) result += 'n' + body.exception.text;
716
717 return result;
718 }
719
720 // This class is the repl-enabled debugger interface which is invoked on
721 // "node debug"
722 function Interface(stdin, stdout, args) {
723 var self = this;
724
725 this.stdin = stdin;
726 this.stdout = stdout;
727 this.args = args;
728
729 // Two eval modes are available: controlEval and debugEval
730 // But controlEval is used by default
731 var opts = {
732 prompt: 'debug> ',
733 input: this.stdin,
734 output: this.stdout,
735 eval: this.controlEval.bind(this),
736 useGlobal: false,
737 ignoreUndefined: true
738 };
739 if (parseInt(process.env['NODE_NO_READLINE'], 10)) {
740 opts.terminal = false;
741 } else if (parseInt(process.env['NODE_FORCE_READLINE'], 10)) {
742 opts.terminal = true;
743
744 // Emulate Ctrl+C if we're emulating terminal
745 if (!this.stdout.isTTY) {
746 process.on('SIGINT', function() {
747 self.repl.rli.emit('SIGINT');
748 });
749 }
750 }
751 if (parseInt(process.env['NODE_DISABLE_COLORS'], 10)) {
752 opts.useColors = false;
753 }
754
755 this.repl = repl.start(opts);
756
757 // Do not print useless warning
758 repl._builtinLibs.splice(repl._builtinLibs.indexOf('repl'), 1);
759
760 // Kill child process when main process dies
761 this.repl.on('exit', function() {
762 process.exit(0);
763 });
764
765 // Handle all possible exits
766 process.on('exit', this.killChild.bind(this));
767 process.once('SIGTERM', process.exit.bind(process, 0));
768 process.once('SIGHUP', process.exit.bind(process, 0));
769
770 var proto = Interface.prototype;
771 const ignored = ['pause', 'resume', 'exitRepl', 'handleBreak',
772 'requireConnection', 'killChild', 'trySpawn',
773 'controlEval', 'debugEval', 'print', 'childPrint',
774 'clearline'];
775 const shortcut = {
776 'run': 'r',
777 'cont': 'c',
778 'next': 'n',
779 'step': 's',
780 'out': 'o',
781 'backtrace': 'bt',
782 'setBreakpoint': 'sb',
783 'clearBreakpoint': 'cb',
784 'pause_': 'pause'
785 };
786
787 function defineProperty(key, protoKey) {
788 // Check arity
789 var fn = proto[protoKey].bind(self);
790
791 if (proto[protoKey].length === 0) {
792 Object.defineProperty(self.repl.context, key, {
793 get: fn,
794 enumerable: true,
795 configurable: false
796 });
797 } else {
798 self.repl.context[key] = fn;
799 }
800 };
801
802 // Copy all prototype methods in repl context
803 // Setup them as getters if possible
804 for (var i in proto) {
805 if (Object.prototype.hasOwnProperty.call(proto, i) &&
806 ignored.indexOf(i) === -1) {
807 defineProperty(i, i);
808 if (shortcut[i]) defineProperty(shortcut[i], i);
809 }
810 }
811
812 this.killed = false;
813 this.waiting = null;
814 this.paused = 0;
815 this.context = this.repl.context;
816 this.history = {
817 debug: [],
818 control: []
819 };
820 this.breakpoints = [];
821 this._watchers = [];
822
823 // Run script automatically
824 this.pause();
825
826 // XXX Need to figure out why we need this delay
827 setTimeout(function() {
828
829 self.run(function() {
830 self.resume();
831 });
832 }, 10);
833 }
834
835
836 // Stream control
837
838
839 Interface.prototype.pause = function() {
840 if (this.killed || this.paused++ > 0) return this;
841 this.repl.rli.pause();
842 this.stdin.pause();
843 return this;
844 };
845
846 Interface.prototype.resume = function(silent) {
847 if (this.killed || this.paused === 0 || --this.paused !== 0) return this;
848 this.repl.rli.resume();
849 if (silent !== true) {
850 this.repl.displayPrompt();
851 }
852 this.stdin.resume();
853
854 if (this.waiting) {
855 this.waiting();
856 this.waiting = null;
857 }
858 return this;
859 };
860
861
862 // Clear current line
863 Interface.prototype.clearline = function() {
864 if (this.stdout.isTTY) {
865 this.stdout.cursorTo(0);
866 this.stdout.clearLine(1);
867 } else {
868 this.stdout.write('b');
869 }
870 };
871
872 // Print text to output stream
873 Interface.prototype.print = function(text, oneline) {
874 if (this.killed) return;
875 this.clearline();
876
877 this.stdout.write(typeof text === 'string' ? text : util.inspect(text));
878
879 if (oneline !== true) {
880 this.stdout.write('n');
881 }
882 };
883
884 // Format and print text from child process
885 Interface.prototype.childPrint = function(text) {
886 this.print(text.toString().split(/rn|r|n/g).filter(function(chunk) {
887 return chunk;
888 }).map(function(chunk) {
889 return '< ' + chunk;
890 }).join('n'));
891 this.repl.displayPrompt(true);
892 };
893
894 // Errors formatting
895 Interface.prototype.error = function(text) {
896 this.print(text);
897 this.resume();
898 };
899
900
901 // Debugger's `break` event handler
902 Interface.prototype.handleBreak = function(r) {
903 var self = this;
904
905 this.pause();
906
907 // Save execution context's data
908 this.client.currentSourceLine = r.sourceLine;
909 this.client.currentSourceLineText = r.sourceLineText;
910 this.client.currentSourceColumn = r.sourceColumn;
911 this.client.currentFrame = 0;
912 this.client.currentScript = r.script && r.script.name;
913
914 // Print break data
915 this.print(SourceInfo(r));
916
917 // Show watchers' values
918 this.watchers(true, function(err) {
919 if (err) return self.error(err);
920
921 // And list source
922 self.list(2);
923
924 self.resume(true);
925 });
926 };
927
928
929 // Internal method for checking connection state
930 Interface.prototype.requireConnection = function() {
931 if (!this.client) {
932 this.error('App isn't running... Try `run` instead');
933 return false;
934 }
935 return true;
936 };
937
938
939 // Evals
940
941 // Used for debugger's commands evaluation and execution
942 Interface.prototype.controlEval = function(code, context, filename, callback) {
943 try {
944 // Repeat last command if empty line are going to be evaluated
945 if (this.repl.rli.history && this.repl.rli.history.length > 0) {
946 if (code === 'n') {
947 code = this.repl.rli.history[0] + 'n';
948 }
949 }
950
951 var result = vm.runInContext(code, context, filename);
952
953 // Repl should not ask for next command
954 // if current one was asynchronous.
955 if (this.paused === 0) return callback(null, result);
956
957 // Add a callback for asynchronous command
958 // (it will be automatically invoked by .resume() method
959 this.waiting = function() {
960 callback(null, result);
961 };
962 } catch (e) {
963 callback(e);
964 }
965 };
966
967 // Used for debugger's remote evaluation (`repl`) commands
968 Interface.prototype.debugEval = function(code, context, filename, callback) {
969 if (!this.requireConnection()) return;
970
971 var self = this,
972 client = this.client;
973
974 // Repl asked for scope variables
975 if (code === '.scope') {
976 client.reqScopes(callback);
977 return;
978 }
979
980 var frame = client.currentFrame === NO_FRAME ? frame : undefined;
981
982 self.pause();
983
984 // Request remote evaluation globally or in current frame
985 client.reqFrameEval(code, frame, function(err, res) {
986 if (err) {
987 callback(err);
988 self.resume(true);
989 return;
990 }
991
992 // Request object by handles (and it's sub-properties)
993 client.mirrorObject(res, 3, function(err, mirror) {
994 callback(null, mirror);
995 self.resume(true);
996 });
997 });
998 };
999
1000
1001 // Utils
1002
1003 // Adds spaces and prefix to number
1004 // maxN is a maximum number we should have space for
1005 function leftPad(n, prefix, maxN) {
1006 var s = n.toString(),
1007 nchars = Math.max(2, String(maxN).length) + 1,
1008 nspaces = nchars - s.length - 1;
1009
1010 for (var i = 0; i < nspaces; i++) {
1011 prefix += ' ';
1012 }
1013
1014 return prefix + s;
1015 }
1016
1017
1018 // Commands
1019
1020
1021 // Print help message
1022 Interface.prototype.help = function() {
1023 this.print(helpMessage);
1024 };
1025
1026
1027 // Run script
1028 Interface.prototype.run = function() {
1029 var callback = arguments[0];
1030
1031 if (this.child) {
1032 this.error('App is already running... Try `restart` instead');
1033 callback && callback(true);
1034 } else {
1035 this.trySpawn(callback);
1036 }
1037 };
1038
1039
1040 // Restart script
1041 Interface.prototype.restart = function() {
1042 if (!this.requireConnection()) return;
1043
1044 var self = this;
1045
1046 self.pause();
1047 self.killChild();
1048
1049 // XXX need to wait a little bit for the restart to work?
1050 setTimeout(function() {
1051 self.trySpawn();
1052 self.resume();
1053 }, 1000);
1054 };
1055
1056
1057 // Print version
1058 Interface.prototype.version = function() {
1059 if (!this.requireConnection()) return;
1060
1061 var self = this;
1062
1063 this.pause();
1064 this.client.reqVersion(function(err, v) {
1065 if (err) {
1066 self.error(err);
1067 } else {
1068 self.print(v);
1069 }
1070 self.resume();
1071 });
1072 };
1073
1074 // List source code
1075 Interface.prototype.list = function(delta) {
1076 if (!this.requireConnection()) return;
1077
1078 delta || (delta = 5);
1079
1080 var self = this,
1081 client = this.client,
1082 from = client.currentSourceLine - delta + 1,
1083 to = client.currentSourceLine + delta + 1;
1084
1085 self.pause();
1086 client.reqSource(from, to, function(err, res) {
1087 if (err || !res) {
1088 self.error('You can't list source code right now');
1089 self.resume();
1090 return;
1091 }
1092
1093 var lines = res.source.split('n');
1094 for (var i = 0; i < lines.length; i++) {
1095 var lineno = res.fromLine + i + 1;
1096 if (lineno < from || lineno > to) continue;
1097
1098 var current = lineno == 1 + client.currentSourceLine,
1099 breakpoint = client.breakpoints.some(function(bp) {
1100 return (bp.scriptReq === client.currentScript ||
1101 bp.script === client.currentScript) &&
1102 bp.line == lineno;
1103 });
1104
1105 if (lineno == 1) {
1106 // The first line needs to have the module wrapper filtered out of
1107 // it.
1108 var wrapper = Module.wrapper[0];
1109 lines[i] = lines[i].slice(wrapper.length);
1110
1111 client.currentSourceColumn -= wrapper.length;
1112 }
1113
1114 // Highlight executing statement
1115 var line;
1116 if (current) {
1117 line = SourceUnderline(lines[i],
1118 client.currentSourceColumn,
1119 self.repl);
1120 } else {
1121 line = lines[i];
1122 }
1123
1124 var prefixChar = ' ';
1125 if (current) {
1126 prefixChar = '>';
1127 } else if (breakpoint) {
1128 prefixChar = '*';
1129 }
1130
1131 self.print(leftPad(lineno, prefixChar, to) + ' ' + line);
1132 }
1133 self.resume();
1134 });
1135 };
1136
1137 // Print backtrace
1138 Interface.prototype.backtrace = function() {
1139 if (!this.requireConnection()) return;
1140
1141 var self = this,
1142 client = this.client;
1143
1144 self.pause();
1145 client.fullTrace(function(err, bt) {
1146 if (err) {
1147 self.error('Can't request backtrace now');
1148 self.resume();
1149 return;
1150 }
1151
1152 if (bt.totalFrames == 0) {
1153 self.print('(empty stack)');
1154 } else {
1155 var trace = [],
1156 firstFrameNative = bt.frames[0].script.isNative;
1157
1158 for (var i = 0; i < bt.frames.length; i++) {
1159 var frame = bt.frames[i];
1160 if (!firstFrameNative && frame.script.isNative) break;
1161
1162 var text = '#' + i + ' ';
1163 if (frame.func.inferredName && frame.func.inferredName.length > 0) {
1164 text += frame.func.inferredName + ' ';
1165 }
1166 text += path.basename(frame.script.name) + ':';
1167 text += (frame.line + 1) + ':' + (frame.column + 1);
1168
1169 trace.push(text);
1170 }
1171
1172 self.print(trace.join('n'));
1173 }
1174
1175 self.resume();
1176 });
1177 };
1178
1179
1180 // First argument tells if it should display internal node scripts or not
1181 // (available only for internal debugger's functions)
1182 Interface.prototype.scripts = function() {
1183 if (!this.requireConnection()) return;
1184
1185 var client = this.client,
1186 displayNatives = arguments[0] || false,
1187 scripts = [];
1188
1189 this.pause();
1190 for (var id in client.scripts) {
1191 var script = client.scripts[id];
1192 if (script !== null && typeof script === 'object' && script.name) {
1193 if (displayNatives ||
1194 script.name == client.currentScript ||
1195 !script.isNative) {
1196 scripts.push(
1197 (script.name == client.currentScript ? '* ' : ' ') +
1198 id + ': ' +
1199 path.basename(script.name)
1200 );
1201 }
1202 }
1203 }
1204 this.print(scripts.join('n'));
1205 this.resume();
1206 };
1207
1208
1209 // Continue execution of script
1210 Interface.prototype.cont = function() {
1211 if (!this.requireConnection()) return;
1212 this.pause();
1213
1214 var self = this;
1215 this.client.reqContinue(function(err) {
1216 if (err) self.error(err);
1217 self.resume();
1218 });
1219 };
1220
1221
1222 // Step commands generator
1223 Interface.stepGenerator = function(type, count) {
1224 return function() {
1225 if (!this.requireConnection()) return;
1226
1227 var self = this;
1228
1229 self.pause();
1230 self.client.step(type, count, function(err, res) {
1231 if (err) self.error(err);
1232 self.resume();
1233 });
1234 };
1235 };
1236
1237
1238 // Jump to next command
1239 Interface.prototype.next = Interface.stepGenerator('next', 1);
1240
1241
1242 // Step in
1243 Interface.prototype.step = Interface.stepGenerator('in', 1);
1244
1245
1246 // Step out
1247 Interface.prototype.out = Interface.stepGenerator('out', 1);
1248
1249
1250 // Watch
1251 Interface.prototype.watch = function(expr) {
1252 this._watchers.push(expr);
1253 };
1254
1255 // Unwatch
1256 Interface.prototype.unwatch = function(expr) {
1257 var index = this._watchers.indexOf(expr);
1258
1259 // Unwatch by expression
1260 // or
1261 // Unwatch by watcher number
1262 this._watchers.splice(index !== -1 ? index : +expr, 1);
1263 };
1264
1265 // List watchers
1266 Interface.prototype.watchers = function() {
1267 var self = this;
1268 var verbose = arguments[0] || false;
1269 var callback = arguments[1] || function() {};
1270 var waiting = this._watchers.length;
1271 var values = [];
1272
1273 this.pause();
1274
1275 if (!waiting) {
1276 this.resume();
1277
1278 return callback();
1279 }
1280
1281 this._watchers.forEach(function(watcher, i) {
1282 self.debugEval(watcher, null, null, function(err, value) {
1283 values[i] = err ? '<error>' : value;
1284 wait();
1285 });
1286 });
1287
1288 function wait() {
1289 if (--waiting === 0) {
1290 if (verbose) self.print('Watchers:');
1291
1292 self._watchers.forEach(function(watcher, i) {
1293 self.print(leftPad(i, ' ', self._watchers.length - 1) +
1294 ': ' + watcher + ' = ' +
1295 JSON.stringify(values[i]));
1296 });
1297
1298 if (verbose) self.print('');
1299
1300 self.resume();
1301
1302 callback(null);
1303 }
1304 }
1305 };
1306
1307 // Break on exception
1308 Interface.prototype.breakOnException = function breakOnException() {
1309 if (!this.requireConnection()) return;
1310
1311 var self = this;
1312
1313 // Break on exceptions
1314 this.pause();
1315 this.client.reqSetExceptionBreak('all', function(err, res) {
1316 self.resume();
1317 });
1318 };
1319
1320 // Add breakpoint
1321 Interface.prototype.setBreakpoint = function(script, line,
1322 condition, silent) {
1323 if (!this.requireConnection()) return;
1324
1325 var self = this,
1326 scriptId,
1327 ambiguous;
1328
1329 // setBreakpoint() should insert breakpoint on current line
1330 if (script === undefined) {
1331 script = this.client.currentScript;
1332 line = this.client.currentSourceLine + 1;
1333 }
1334
1335 // setBreakpoint(line-number) should insert breakpoint in current script
1336 if (line === undefined && typeof script === 'number') {
1337 line = script;
1338 script = this.client.currentScript;
1339 }
1340
1341 if (script === undefined) {
1342 this.print('Cannot determine the current script, ' +
1343 'make sure the debugged process is paused.');
1344 return;
1345 }
1346
1347 if (/()$/.test(script)) {
1348 // setBreakpoint('functionname()');
1349 var req = {
1350 type: 'function',
1351 target: script.replace(/()$/, ''),
1352 condition: condition
1353 };
1354 } else {
1355 // setBreakpoint('scriptname')
1356 if (script != +script && !this.client.scripts[script]) {
1357 var scripts = this.client.scripts;
1358 for (var id in scripts) {
1359 if (scripts[id] &&
1360 scripts[id].name &&
1361 scripts[id].name.indexOf(script) !== -1) {
1362 if (scriptId) {
1363 ambiguous = true;
1364 }
1365 scriptId = id;
1366 }
1367 }
1368 } else {
1369 scriptId = script;
1370 }
1371
1372 if (ambiguous) return this.error('Script name is ambiguous');
1373 if (line <= 0) return this.error('Line should be a positive value');
1374
1375 var req;
1376 if (scriptId) {
1377 req = {
1378 type: 'scriptId',
1379 target: scriptId,
1380 line: line - 1,
1381 condition: condition
1382 };
1383 } else {
1384 this.print('Warning: script '' + script + '' was not loaded yet.');
1385 var escapedPath = script.replace(/([/.?*()^${}|[]])/g, '$1');
1386 var scriptPathRegex = '^(.*[/])?' + escapedPath + '$';
1387 req = {
1388 type: 'scriptRegExp',
1389 target: scriptPathRegex,
1390 line: line - 1,
1391 condition: condition
1392 };
1393 }
1394 }
1395
1396 self.pause();
1397 self.client.setBreakpoint(req, function(err, res) {
1398 if (err) {
1399 if (!silent) {
1400 self.error(err);
1401 }
1402 } else {
1403 if (!silent) {
1404 self.list(5);
1405 }
1406
1407 // Try load scriptId and line from response
1408 if (!scriptId) {
1409 scriptId = res.script_id;
1410 line = res.line + 1;
1411 }
1412
1413 // Remember this breakpoint even if scriptId is not resolved yet
1414 self.client.breakpoints.push({
1415 id: res.breakpoint,
1416 scriptId: scriptId,
1417 script: (self.client.scripts[scriptId] || {}).name,
1418 line: line,
1419 condition: condition,
1420 scriptReq: script
1421 });
1422 }
1423 self.resume();
1424 });
1425 };
1426
1427 // Clear breakpoint
1428 Interface.prototype.clearBreakpoint = function(script, line) {
1429 if (!this.requireConnection()) return;
1430
1431 var ambiguous,
1432 breakpoint,
1433 scriptId,
1434 index;
1435
1436 this.client.breakpoints.some(function(bp, i) {
1437 if (bp.scriptId === script ||
1438 bp.scriptReq === script ||
1439 (bp.script && bp.script.indexOf(script) !== -1)) {
1440 if (index !== undefined) {
1441 ambiguous = true;
1442 }
1443 scriptId = script;
1444 if (bp.line === line) {
1445 index = i;
1446 breakpoint = bp.id;
1447 return true;
1448 }
1449 }
1450 });
1451
1452 if (!scriptId && !this.client.scripts[script]) {
1453 var scripts = this.client.scripts;
1454 for (var id in scripts) {
1455 if (scripts[id] &&
1456 scripts[id].name &&
1457 scripts[id].name.indexOf(script) !== -1) {
1458 if (scriptId) {
1459 ambiguous = true;
1460 }
1461 scriptId = id;
1462 }
1463 }
1464 }
1465
1466 if (ambiguous) return this.error('Script name is ambiguous');
1467
1468 if (scriptId === undefined) {
1469 return this.error('Script ' + script + ' not found');
1470 }
1471
1472 if (breakpoint === undefined) {
1473 return this.error('Breakpoint not found on line ' + line);
1474 }
1475
1476 var self = this,
1477 req = {
1478 breakpoint: breakpoint
1479 };
1480
1481 self.pause();
1482 self.client.clearBreakpoint(req, function(err, res) {
1483 if (err) {
1484 self.error(err);
1485 } else {
1486 self.client.breakpoints.splice(index, 1);
1487 self.list(5);
1488 }
1489 self.resume();
1490 });
1491 };
1492
1493
1494 // Show breakpoints
1495 Interface.prototype.breakpoints = function() {
1496 if (!this.requireConnection()) return;
1497
1498 this.pause();
1499 var self = this;
1500 this.client.listbreakpoints(function(err, res) {
1501 if (err) {
1502 self.error(err);
1503 } else {
1504 self.print(res);
1505 self.resume();
1506 }
1507 });
1508 };
1509
1510
1511 // Pause child process
1512 Interface.prototype.pause_ = function() {
1513 if (!this.requireConnection()) return;
1514
1515 var self = this,
1516 cmd = 'process._debugPause();';
1517
1518 this.pause();
1519 this.client.reqFrameEval(cmd, NO_FRAME, function(err, res) {
1520 if (err) {
1521 self.error(err);
1522 } else {
1523 self.resume();
1524 }
1525 });
1526 };
1527
1528
1529 // Kill child process
1530 Interface.prototype.kill = function() {
1531 if (!this.child) return;
1532 this.killChild();
1533 };
1534
1535
1536 // Activate debug repl
1537 Interface.prototype.repl = function() {
1538 if (!this.requireConnection()) return;
1539
1540 var self = this;
1541
1542 self.print('Press Ctrl + C to leave debug repl');
1543
1544 // Don't display any default messages
1545 var listeners = this.repl.rli.listeners('SIGINT').slice(0);
1546 this.repl.rli.removeAllListeners('SIGINT');
1547
1548 // Exit debug repl on Ctrl + C
1549 this.repl.rli.once('SIGINT', function() {
1550 // Restore all listeners
1551 process.nextTick(function() {
1552 listeners.forEach(function(listener) {
1553 self.repl.rli.on('SIGINT', listener);
1554 });
1555 });
1556
1557 // Exit debug repl
1558 self.exitRepl();
1559 });
1560
1561 // Set new
1562 this.repl.eval = this.debugEval.bind(this);
1563 this.repl.context = {};
1564
1565 // Swap history
1566 this.history.control = this.repl.rli.history;
1567 this.repl.rli.history = this.history.debug;
1568
1569 this.repl.rli.setPrompt('> ');
1570 this.repl.displayPrompt();
1571 };
1572
1573
1574 // Exit debug repl
1575 Interface.prototype.exitRepl = function() {
1576 // Restore eval
1577 this.repl.eval = this.controlEval.bind(this);
1578
1579 // Swap history
1580 this.history.debug = this.repl.rli.history;
1581 this.repl.rli.history = this.history.control;
1582
1583 this.repl.context = this.context;
1584 this.repl.rli.setPrompt('debug> ');
1585 this.repl.displayPrompt();
1586 };
1587
1588
1589 // Quit
1590 Interface.prototype.quit = function() {
1591 this.killChild();
1592 process.exit(0);
1593 };
1594
1595
1596 // Kills child process
1597 Interface.prototype.killChild = function() {
1598 if (this.child) {
1599 this.child.kill();
1600 this.child = null;
1601 }
1602
1603 if (this.client) {
1604 // Save breakpoints
1605 this.breakpoints = this.client.breakpoints;
1606
1607 this.client.destroy();
1608 this.client = null;
1609 }
1610 };
1611
1612
1613 // Spawns child process (and restores breakpoints)
1614 Interface.prototype.trySpawn = function(cb) {
1615 var self = this,
1616 breakpoints = this.breakpoints || [],
1617 port = exports.port,
1618 host = '127.0.0.1',
1619 childArgs = this.args;
1620
1621 this.killChild();
1622 assert(!this.child);
1623
1624 var isRemote = false;
1625 if (this.args.length === 2) {
1626 var match = this.args[1].match(/^([^:]+):(d+)$/);
1627
1628 if (match) {
1629 // Connecting to remote debugger
1630 // `node debug localhost:5858`
1631 host = match[1];
1632 port = parseInt(match[2], 10);
1633 isRemote = true;
1634 }
1635 } else if (this.args.length === 3) {
1636 // `node debug -p pid`
1637 if (this.args[1] === '-p' && /^d+$/.test(this.args[2])) {
1638 const pid = parseInt(this.args[2], 10);
1639 try {
1640 process._debugProcess(pid);
1641 } catch (e) {
1642 if (e.code === 'ESRCH') {
1643 console.error(`Target process: ${pid} doesn't exist.`);
1644 process.exit(1);
1645 }
1646 throw e;
1647 }
1648 isRemote = true;
1649 } else {
1650 var match = this.args[1].match(/^--port=(d+)$/);
1651 if (match) {
1652 // Start debugger on custom port
1653 // `node debug --port=5858 app.js`
1654 port = parseInt(match[1], 10);
1655 childArgs = ['--debug-brk=' + port].concat(this.args.slice(2));
1656 }
1657 }
1658 }
1659
1660 if (!isRemote) {
1661 // pipe stream into debugger
1662 this.child = spawn(process.execPath, childArgs);
1663
1664 this.child.stdout.on('data', this.childPrint.bind(this));
1665 this.child.stderr.on('data', this.childPrint.bind(this));
1666 }
1667
1668 this.pause();
1669
1670 var client = self.client = new Client(),
1671 connectionAttempts = 0;
1672
1673 client.once('ready', function() {
1674 self.stdout.write(' okn');
1675
1676 // Restore breakpoints
1677 breakpoints.forEach(function(bp) {
1678 self.print('Restoring breakpoint ' + bp.scriptReq + ':' + bp.line);
1679 self.setBreakpoint(bp.scriptReq, bp.line, bp.condition, true);
1680 });
1681
1682 client.on('close', function() {
1683 self.pause();
1684 self.print('program terminated');
1685 self.resume();
1686 self.client = null;
1687 self.killChild();
1688 });
1689
1690 if (cb) cb();
1691 self.resume();
1692 });
1693
1694 client.on('unhandledResponse', function(res) {
1695 self.pause();
1696 self.print('nunhandled res:' + JSON.stringify(res));
1697 self.resume();
1698 });
1699
1700 client.on('break', function(res) {
1701 self.handleBreak(res.body);
1702 });
1703
1704 client.on('exception', function(res) {
1705 self.handleBreak(res.body);
1706 });
1707
1708 client.on('error', connectError);
1709 function connectError() {
1710 // If it's failed to connect 10 times then print failed message
1711 if (connectionAttempts >= 10) {
1712 console.error(' failed, please retry');
1713 process.exit(1);
1714 }
1715 setTimeout(attemptConnect, 500);
1716 }
1717
1718 function attemptConnect() {
1719 ++connectionAttempts;
1720 self.stdout.write('.');
1721 client.connect(port, host);
1722 }
1723
1724 self.print('connecting to ' + host + ':' + port + ' ..', true);
1725 if (isRemote) {
1726 attemptConnect();
1727 } else {
1728 this.child.stderr.once('data', function() {
1729 setImmediate(attemptConnect);
1730 });
1731 }
1732 };
/home/cabox/workspace/desktop/ionic/iojs-3.3.1/lib/_debugger.js 232 // ???
/home/cabox/workspace/desktop/ionic/iojs-3.3.1/lib/_debugger.js 274 // TODO: We have a cache of handle's we've already seen in this.handles
/home/cabox/workspace/desktop/ionic/iojs-3.3.1/lib/_debugger.js 398 // TODO: from, to, bottom
/home/cabox/workspace/desktop/ionic/iojs-3.3.1/lib/_debugger.js 405 // TODO: from, to, bottom
/home/cabox/workspace/abakasam/scripts/code/...code
/home/cabox/workspace/desktop/ionic/iojs-3.3.1/lib/_debugger.js
HELLO 
HELLO strict';
HELLO 
HELLO util
HELLO path
HELLO net
HELLO vm
HELLO Module
HELLO repl
HELLO inherits
HELLO assert
HELLO spawn
HELLO Buffer
HELLO 
HELLO =
HELLO ||
HELLO 
HELLO (argv.length
HELLO iojs
HELLO iojs
HELLO iojs
HELLO 
HELLO 
HELLO 
HELLO Setup
HELLO =
HELLO =
HELLO 
HELLO args
HELLO =
HELLO 
HELLO 
HELLO 
HELLO function(e)
HELLO was
HELLO report
HELLO 
HELLO 
HELLO (interface_.child)
HELLO 
HELLO 
HELLO 
HELLO 
HELLO =
HELLO 
HELLO 
HELLO 
HELLO Parser/Serializer
HELLO http//code.google.com/p/v8/wiki/DebuggerProtocol
HELLO 
HELLO Usage
HELLO p
HELLO 
HELLO p.onResponse
HELLO //
HELLO };
HELLO 
HELLO socket.setEncoding('utf8');
HELLO socket.on('data',
HELLO //
HELLO p.execute(s);
HELLO });
HELLO 
HELLO 
HELLO Protocol()
HELLO 
HELLO 
HELLO =
HELLO 
HELLO 
HELLO =
HELLO =
HELLO =
HELLO =
HELLO 
HELLO 
HELLO 
HELLO 
HELLO =
HELLO res
HELLO +=
HELLO 
HELLO (this.state)
HELLO 'headers'
HELLO endHeaderIndex
HELLO 
HELLO (endHeaderIndex
HELLO 
HELLO rawHeader
HELLO endHeaderByteIndex
HELLO lines
HELLO (var
HELLO kv
HELLO =
HELLO 
HELLO 
HELLO =
HELLO =
HELLO 
HELLO =
HELLO 
HELLO len
HELLO (len
HELLO 
HELLO 
HELLO falls
HELLO 'body'
HELLO resRawByteLength
HELLO 
HELLO (resRawByteLength
HELLO buf
HELLO 0,
HELLO =
HELLO 
HELLO +
HELLO 
HELLO JSON
HELLO =
HELLO 
HELLO Done!
HELLO 
HELLO 
HELLO +
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO new
HELLO 
HELLO 
HELLO 
HELLO 
HELLO =
HELLO =
HELLO =
HELLO json
HELLO 'Content-Length
HELLO +
HELLO 
HELLO 
HELLO 
HELLO NO_FRAME
HELLO 
HELLO Client()
HELLO 
HELLO protocol
HELLO =
HELLO socket
HELLO 
HELLO =
HELLO =
HELLO =
HELLO =
HELLO =
HELLO 
HELLO Note
HELLO 
HELLO function(d)
HELLO 
HELLO 
HELLO 
HELLO =
HELLO 
HELLO net.Stream);
HELLO =
HELLO 
HELLO 
HELLO =
HELLO (desc
HELLO desc.handle
HELLO 
HELLO 
HELLO 
HELLO =
HELLO 
HELLO (desc.type
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO natives
HELLO 
HELLO 
HELLO =
HELLO =
HELLO (desc.name)
HELLO =
HELLO ==
HELLO 
HELLO 
HELLO 
HELLO 
HELLO =
HELLO =
HELLO 
HELLO 
HELLO 
HELLO =
HELLO cb,
HELLO =
HELLO 
HELLO i)
HELLO (fn.request_seq
HELLO =
HELLO =
HELLO true;
HELLO 
HELLO 
HELLO 
HELLO self
HELLO handled
HELLO 
HELLO (res.headers.Type
HELLO Request
HELLO 
HELLO 
HELLO =
HELLO 
HELLO else
HELLO res.body);
HELLO =
HELLO 
HELLO else
HELLO res.body);
HELLO =
HELLO 
HELLO else
HELLO 
HELLO =
HELLO 
HELLO else
HELLO ???
HELLO 
HELLO =
HELLO 
HELLO else
HELLO This
HELLO future?
HELLO =
HELLO 
HELLO 
HELLO (cb)
HELLO 1);
HELLO =
HELLO 
HELLO err
HELLO ===
HELLO res.body
HELLO 
HELLO 
HELLO (!handled)
HELLO 
HELLO 
HELLO 
HELLO =
HELLO 
HELLO =
HELLO 
HELLO 
HELLO 
HELLO 
HELLO =
HELLO =
HELLO command
HELLO (err)
HELLO res.body.body.V8Version,
HELLO 
HELLO 
HELLO 
HELLO 
HELLO =
HELLO self
HELLO 
HELLO TODO
HELLO This
HELLO req
HELLO 'lookup',
HELLO {
HELLO refs
HELLO 
HELLO 
HELLO 
HELLO =
HELLO function(err,
HELLO (err)
HELLO (var
HELLO (res[ref]
HELLO 
HELLO 
HELLO 
HELLO 
HELLO res);
HELLO 
HELLO 
HELLO 
HELLO =
HELLO self
HELLO =
HELLO 'scopes',
HELLO {}
HELLO 
HELLO 
HELLO =
HELLO function(err,
HELLO (err)
HELLO refs
HELLO scope.object.ref;
HELLO 
HELLO 
HELLO function(err,
HELLO (err)
HELLO 
HELLO globals
HELLO res[key].properties.map(function(prop)
HELLO prop.name;
HELLO 
HELLO 
HELLO 
HELLO globals.reverse());
HELLO 
HELLO 
HELLO 
HELLO 
HELLO This
HELLO scopes
HELLO =
HELLO self
HELLO 
HELLO (this.currentFrame
HELLO Only
HELLO NO_FRAME,
HELLO 
HELLO 
HELLO 
HELLO =
HELLO Otherwise
HELLO bt)
HELLO (err
HELLO ??
HELLO cb(null,
HELLO 
HELLO 
HELLO frame
HELLO 
HELLO evalFrames
HELLO (!s)
HELLO x
HELLO (!x)
HELLO x.index;
HELLO 
HELLO 
HELLO evalFrames,
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Finds
HELLO =
HELLO (evalFrames.length
HELLO Just
HELLO NO_FRAME,
HELLO 
HELLO 
HELLO 
HELLO self
HELLO i
HELLO 
HELLO =
HELLO i,
HELLO (!err)
HELLO evalFrames,
HELLO 
HELLO 
HELLO 
HELLO 
HELLO =
HELLO self
HELLO req
HELLO 'evaluate',
HELLO {
HELLO 
HELLO 
HELLO (frame
HELLO =
HELLO else
HELLO =
HELLO 
HELLO 
HELLO =
HELLO function(err,
HELLO (!err)
HELLO res);
HELLO 
HELLO 
HELLO 
HELLO 
HELLO reqBacktrace(cb)
HELLO TODO
HELLO =
HELLO command
HELLO 
HELLO 
HELLO 
HELLO reqSetExceptionBreak(type,
HELLO TODO
HELLO =
HELLO 
HELLO 'setexceptionbreak',
HELLO {
HELLO cb);
HELLO 
HELLO 
HELLO 
HELLO Returns
HELLO 
HELLO {
HELLO type
HELLO name
HELLO id
HELLO lineOffset
HELLO columnOffset
HELLO lineCount
HELLO sourceStart
HELLO sourceLength
HELLO scriptType
HELLO compilationType
HELLO context
HELLO text
HELLO 
HELLO =
HELLO self
HELLO =
HELLO 
HELLO command
HELLO (err)
HELLO 
HELLO (var
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO =
HELLO =
HELLO command
HELLO 
HELLO 
HELLO =
HELLO command
HELLO 
HELLO 
HELLO =
HELLO =
HELLO 'setbreakpoint',
HELLO req
HELLO 
HELLO 
HELLO cb);
HELLO 
HELLO 
HELLO =
HELLO req
HELLO 'clearbreakpoint',
HELLO req
HELLO 
HELLO 
HELLO cb);
HELLO 
HELLO 
HELLO =
HELLO req
HELLO 'source',
HELLO from,
HELLO to
HELLO 
HELLO 
HELLO cb);
HELLO 
HELLO 
HELLO 
HELLO client.next(1,
HELLO =
HELLO req
HELLO 'continue',
HELLO {
HELLO 
HELLO 
HELLO =
HELLO cb);
HELLO 
HELLO 
HELLO 
HELLO =
HELLO self
HELLO 
HELLO val;
HELLO 
HELLO (handle.type
HELLO The
HELLO {
HELLO type
HELLO className
HELLO constructorFunction
HELLO protoObject
HELLO prototypeObject
HELLO properties
HELLO text
HELLO 
HELLO For
HELLO TJ's
HELLO https//groups.google.com/forum/?pli=1#!topic/nodejs-dev/4gkWBOimiOg
HELLO 
HELLO propertyRefs
HELLO p.ref;
HELLO 
HELLO 
HELLO =
HELLO function(err,
HELLO (err)
HELLO with
HELLO handle);
HELLO 
HELLO 
HELLO 
HELLO mirror,
HELLO =
HELLO 
HELLO (handle.className
HELLO =
HELLO else
HELLO =
HELLO else
HELLO =
HELLO 
HELLO 
HELLO 
HELLO keyValues
HELLO i)
HELLO value
HELLO mirrorValue;
HELLO (value)
HELLO =
HELLO else
HELLO =
HELLO 
HELLO 
HELLO (Array.isArray(mirror)
HELLO Skip
HELLO 
HELLO 
HELLO 
HELLO =
HELLO prop.name,
HELLO mirrorValue
HELLO 
HELLO (value
HELLO 
HELLO depth
HELLO (!err)
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO waitForOthers()
HELLO (--waiting
HELLO {
HELLO =
HELLO 
HELLO mirror);
HELLO 
HELLO 
HELLO 
HELLO 
HELLO else
HELLO =
HELLO else
HELLO =
HELLO else
HELLO =
HELLO else
HELLO =
HELLO else
HELLO =
HELLO 
HELLO null,
HELLO 
HELLO 
HELLO 
HELLO =
HELLO self
HELLO 
HELLO =
HELLO trace)
HELLO (err)
HELLO (trace.totalFrames
HELLO 
HELLO refs
HELLO 
HELLO (var
HELLO frame
HELLO looks
HELLO {
HELLO index
HELLO receiver
HELLO func
HELLO script
HELLO constructCall
HELLO atReturn
HELLO debuggerFrame
HELLO arguments
HELLO locals
HELLO position
HELLO line
HELLO column
HELLO sourceLineText
HELLO scopes
HELLO text
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO function(err,
HELLO (err)
HELLO 
HELLO (var
HELLO frame
HELLO =
HELLO =
HELLO =
HELLO 
HELLO 
HELLO trace);
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO commands
HELLO 
HELLO (r)',
HELLO (c)',
HELLO (n)',
HELLO (s)',
HELLO (o)',
HELLO (bt)',
HELLO (sb)',
HELLO (cb)'
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO helpMessage
HELLO group.join(',
HELLO 
HELLO 
HELLO 
HELLO SourceUnderline(sourceText,
HELLO (!sourceText)
HELLO 
HELLO head
HELLO =
HELLO 
HELLO Colourize
HELLO (repl.useColors)
HELLO =
HELLO 
HELLO 
HELLO Return
HELLO [
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO SourceInfo(body)
HELLO result
HELLO 
HELLO (body.script)
HELLO (body.script.name)
HELLO name
HELLO =
HELLO 
HELLO Change
HELLO (name.indexOf(dir)
HELLO =
HELLO 
HELLO 
HELLO +=
HELLO else
HELLO +=
HELLO 
HELLO 
HELLO +=
HELLO +=
HELLO 
HELLO (body.exception)
HELLO 
HELLO result;
HELLO 
HELLO 
HELLO This
HELLO "node
HELLO Interface(stdin,
HELLO self
HELLO 
HELLO =
HELLO =
HELLO =
HELLO 
HELLO Two
HELLO But
HELLO opts
HELLO 'debug>
HELLO this.stdin,
HELLO this.stdout,
HELLO this.controlEval.bind(this),
HELLO false,
HELLO true
HELLO 
HELLO (parseInt(process.env['NODE_NO_READLINE'],
HELLO =
HELLO else
HELLO =
HELLO 
HELLO Emulate
HELLO (!this.stdout.isTTY)
HELLO function()
HELLO 
HELLO 
HELLO 
HELLO 
HELLO (parseInt(process.env['NODE_DISABLE_COLORS'],
HELLO =
HELLO 
HELLO 
HELLO =
HELLO 
HELLO Do
HELLO 1);
HELLO 
HELLO Kill
HELLO function()
HELLO 
HELLO 
HELLO 
HELLO Handle
HELLO this.killChild.bind(this));
HELLO process.exit.bind(process,
HELLO process.exit.bind(process,
HELLO 
HELLO proto
HELLO ignored
HELLO 'killChild',
HELLO 'debugEval',
HELLO 
HELLO shortcut
HELLO 'r',
HELLO 'c',
HELLO 'n',
HELLO 's',
HELLO 'o',
HELLO 'bt',
HELLO 'sb',
HELLO 'cb',
HELLO 'pause'
HELLO 
HELLO 
HELLO defineProperty(key,
HELLO Check
HELLO fn
HELLO 
HELLO (proto[protoKey].length
HELLO key,
HELLO fn,
HELLO true,
HELLO false
HELLO 
HELLO else
HELLO =
HELLO 
HELLO 
HELLO 
HELLO Copy
HELLO Setup
HELLO (var
HELLO (Object.prototype.hasOwnProperty.call(proto,
HELLO ===
HELLO i);
HELLO (shortcut[i])
HELLO 
HELLO 
HELLO 
HELLO =
HELLO =
HELLO =
HELLO =
HELLO =
HELLO [],
HELLO []
HELLO 
HELLO =
HELLO =
HELLO 
HELLO Run
HELLO 
HELLO 
HELLO XXX
HELLO {
HELLO 
HELLO {
HELLO 
HELLO 
HELLO 10);
HELLO 
HELLO 
HELLO 
HELLO Stream
HELLO 
HELLO 
HELLO =
HELLO (this.killed
HELLO 
HELLO 
HELLO this;
HELLO 
HELLO 
HELLO =
HELLO (this.killed
HELLO 
HELLO (silent
HELLO 
HELLO 
HELLO 
HELLO 
HELLO (this.waiting)
HELLO 
HELLO =
HELLO 
HELLO this;
HELLO 
HELLO 
HELLO 
HELLO Clear
HELLO =
HELLO (this.stdout.isTTY)
HELLO 
HELLO 
HELLO else
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Print
HELLO =
HELLO (this.killed)
HELLO 
HELLO 
HELLO text
HELLO 
HELLO (oneline
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Format
HELLO =
HELLO {
HELLO chunk;
HELLO {
HELLO '<
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Errors
HELLO =
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Debugger's
HELLO =
HELLO self
HELLO 
HELLO 
HELLO 
HELLO Save
HELLO =
HELLO =
HELLO =
HELLO =
HELLO =
HELLO 
HELLO Print
HELLO 
HELLO 
HELLO Show
HELLO function(err)
HELLO (err)
HELLO 
HELLO And
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Internal
HELLO =
HELLO (!this.client)
HELLO isn't
HELLO false;
HELLO 
HELLO true;
HELLO 
HELLO 
HELLO 
HELLO Evals
HELLO 
HELLO Used
HELLO =
HELLO {
HELLO Repeat
HELLO (this.repl.rli.history
HELLO (code
HELLO =
HELLO 
HELLO 
HELLO 
HELLO result
HELLO 
HELLO Repl
HELLO if
HELLO (this.paused
HELLO 
HELLO Add
HELLO (it
HELLO =
HELLO result);
HELLO 
HELLO catch
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Used
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO self
HELLO =
HELLO 
HELLO Repl
HELLO (code
HELLO 
HELLO 
HELLO 
HELLO 
HELLO frame
HELLO 
HELLO 
HELLO 
HELLO Request
HELLO frame,
HELLO (err)
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Request
HELLO 3,
HELLO mirror);
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Utils
HELLO 
HELLO Adds
HELLO maxN
HELLO leftPad(n,
HELLO s
HELLO =
HELLO =
HELLO 
HELLO (var
HELLO +=
HELLO 
HELLO 
HELLO prefix
HELLO 
HELLO 
HELLO 
HELLO Commands
HELLO 
HELLO 
HELLO Print
HELLO =
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Run
HELLO =
HELLO callback
HELLO 
HELLO (this.child)
HELLO is
HELLO &&
HELLO else
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Restart
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO self
HELLO 
HELLO 
HELLO 
HELLO 
HELLO XXX
HELLO {
HELLO 
HELLO 
HELLO 1000);
HELLO 
HELLO 
HELLO 
HELLO Print
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO self
HELLO 
HELLO 
HELLO v)
HELLO (err)
HELLO 
HELLO else
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO List
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO ||
HELLO 
HELLO self
HELLO =
HELLO =
HELLO =
HELLO 
HELLO 
HELLO to,
HELLO (err
HELLO can't
HELLO 
HELLO 
HELLO 
HELLO 
HELLO lines
HELLO (var
HELLO lineno
HELLO (lineno
HELLO 
HELLO current
HELLO =
HELLO (bp.scriptReq
HELLO ===
HELLO ==
HELLO 
HELLO 
HELLO (lineno
HELLO The
HELLO it.
HELLO wrapper
HELLO =
HELLO 
HELLO -=
HELLO 
HELLO 
HELLO Highlight
HELLO line;
HELLO (current)
HELLO =
HELLO 
HELLO 
HELLO else
HELLO =
HELLO 
HELLO 
HELLO prefixChar
HELLO (current)
HELLO =
HELLO else
HELLO =
HELLO 
HELLO 
HELLO prefixChar,
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Print
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO self
HELLO =
HELLO 
HELLO 
HELLO bt)
HELLO (err)
HELLO request
HELLO 
HELLO 
HELLO 
HELLO 
HELLO (bt.totalFrames
HELLO stack)');
HELLO else
HELLO trace
HELLO =
HELLO 
HELLO (var
HELLO frame
HELLO (!firstFrameNative
HELLO 
HELLO text
HELLO (frame.func.inferredName
HELLO +=
HELLO 
HELLO +=
HELLO +=
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO First
HELLO (available
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO client
HELLO =
HELLO =
HELLO 
HELLO 
HELLO (var
HELLO script
HELLO (script
HELLO (displayNatives
HELLO ==
HELLO {
HELLO 
HELLO ==
HELLO +
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Continue
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO 
HELLO self
HELLO {
HELLO (err)
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Step
HELLO =
HELLO function()
HELLO (!this.requireConnection())
HELLO 
HELLO self
HELLO 
HELLO 
HELLO count,
HELLO (err)
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Jump
HELLO =
HELLO 
HELLO 
HELLO Step
HELLO =
HELLO 
HELLO 
HELLO Step
HELLO =
HELLO 
HELLO 
HELLO Watch
HELLO =
HELLO 
HELLO 
HELLO 
HELLO Unwatch
HELLO =
HELLO index
HELLO 
HELLO Unwatch
HELLO or
HELLO Unwatch
HELLO !==
HELLO 
HELLO 
HELLO List
HELLO =
HELLO self
HELLO verbose
HELLO callback
HELLO waiting
HELLO values
HELLO 
HELLO 
HELLO 
HELLO (!waiting)
HELLO 
HELLO 
HELLO callback();
HELLO 
HELLO 
HELLO i)
HELLO null,
HELLO =
HELLO 
HELLO 
HELLO 
HELLO 
HELLO wait()
HELLO (--waiting
HELLO (verbose)
HELLO 
HELLO i)
HELLO '
HELLO '
HELLO 
HELLO 
HELLO 
HELLO (verbose)
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Break
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO self
HELLO 
HELLO Break
HELLO 
HELLO function(err,
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Add
HELLO =
HELLO silent)
HELLO (!this.requireConnection())
HELLO 
HELLO self
HELLO 
HELLO 
HELLO 
HELLO setBreakpoint()
HELLO (script
HELLO =
HELLO =
HELLO 
HELLO 
HELLO setBreakpoint(line-number)
HELLO (line
HELLO =
HELLO =
HELLO 
HELLO 
HELLO (script
HELLO determine
HELLO sure
HELLO 
HELLO 
HELLO 
HELLO (/()$/.test(script))
HELLO setBreakpoint('functionname()');
HELLO req
HELLO 'function',
HELLO script.replace(/()$/,
HELLO condition
HELLO 
HELLO else
HELLO setBreakpoint('scriptname')
HELLO (script
HELLO scripts
HELLO (var
HELLO (scripts[id]
HELLO &&
HELLO !==
HELLO (scriptId)
HELLO =
HELLO 
HELLO =
HELLO 
HELLO 
HELLO else
HELLO =
HELLO 
HELLO 
HELLO (ambiguous)
HELLO (line
HELLO 
HELLO req;
HELLO (scriptId)
HELLO =
HELLO 'scriptId',
HELLO scriptId,
HELLO line
HELLO condition
HELLO 
HELLO else
HELLO script
HELLO escapedPath
HELLO scriptPathRegex
HELLO =
HELLO 'scriptRegExp',
HELLO scriptPathRegex,
HELLO line
HELLO condition
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO function(err,
HELLO (err)
HELLO (!silent)
HELLO 
HELLO 
HELLO else
HELLO (!silent)
HELLO 
HELLO 
HELLO 
HELLO Try
HELLO (!scriptId)
HELLO =
HELLO =
HELLO 
HELLO 
HELLO Remember
HELLO 
HELLO res.breakpoint,
HELLO scriptId,
HELLO (self.client.scripts[scriptId]
HELLO line,
HELLO condition,
HELLO script
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Clear
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO ambiguous,
HELLO 
HELLO 
HELLO 
HELLO 
HELLO i)
HELLO (bp.scriptId
HELLO ===
HELLO &&
HELLO (index
HELLO =
HELLO 
HELLO =
HELLO (bp.line
HELLO =
HELLO =
HELLO true;
HELLO 
HELLO 
HELLO 
HELLO 
HELLO (!scriptId
HELLO scripts
HELLO (var
HELLO (scripts[id]
HELLO &&
HELLO !==
HELLO (scriptId)
HELLO =
HELLO 
HELLO =
HELLO 
HELLO 
HELLO 
HELLO 
HELLO (ambiguous)
HELLO 
HELLO (scriptId
HELLO this.error('Script
HELLO 
HELLO 
HELLO (breakpoint
HELLO this.error('Breakpoint
HELLO 
HELLO 
HELLO self
HELLO =
HELLO breakpoint
HELLO 
HELLO 
HELLO 
HELLO function(err,
HELLO (err)
HELLO 
HELLO else
HELLO 1);
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Show
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO 
HELLO self
HELLO res)
HELLO (err)
HELLO 
HELLO else
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Pause
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO self
HELLO =
HELLO 
HELLO 
HELLO NO_FRAME,
HELLO (err)
HELLO 
HELLO else
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Kill
HELLO =
HELLO (!this.child)
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Activate
HELLO =
HELLO (!this.requireConnection())
HELLO 
HELLO self
HELLO 
HELLO Ctrl
HELLO 
HELLO Don't
HELLO listeners
HELLO 
HELLO 
HELLO Exit
HELLO function()
HELLO Restore
HELLO {
HELLO {
HELLO listener);
HELLO 
HELLO 
HELLO 
HELLO Exit
HELLO 
HELLO 
HELLO 
HELLO Set
HELLO =
HELLO =
HELLO 
HELLO Swap
HELLO =
HELLO =
HELLO 
HELLO ');
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Exit
HELLO =
HELLO Restore
HELLO =
HELLO 
HELLO Swap
HELLO =
HELLO =
HELLO 
HELLO =
HELLO ');
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Quit
HELLO =
HELLO 
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Kills
HELLO =
HELLO (this.child)
HELLO 
HELLO =
HELLO 
HELLO 
HELLO (this.client)
HELLO Save
HELLO =
HELLO 
HELLO 
HELLO =
HELLO 
HELLO 
HELLO 
HELLO 
HELLO Spawns
HELLO =
HELLO self
HELLO =
HELLO =
HELLO =
HELLO =
HELLO 
HELLO 
HELLO 
HELLO 
HELLO isRemote
HELLO (this.args.length
HELLO match
HELLO 
HELLO (match)
HELLO Connecting
HELLO `node
HELLO =
HELLO =
HELLO =
HELLO 
HELLO else
HELLO `node
HELLO (this.args[1]
HELLO pid
HELLO {
HELLO 
HELLO catch
HELLO (e.code
HELLO process
HELLO 
HELLO 
HELLO e;
HELLO 
HELLO =
HELLO else
HELLO match
HELLO (match)
HELLO Start
HELLO `node
HELLO =
HELLO =
HELLO 
HELLO 
HELLO 
HELLO 
HELLO (!isRemote)
HELLO pipe
HELLO =
HELLO 
HELLO this.childPrint.bind(this));
HELLO this.childPrint.bind(this));
HELLO 
HELLO 
HELLO 
HELLO 
HELLO client
HELLO =
HELLO 
HELLO function()
HELLO okn');
HELLO 
HELLO Restore
HELLO {
HELLO breakpoint
HELLO bp.line,
HELLO 
HELLO 
HELLO function()
HELLO 
HELLO terminated');
HELLO 
HELLO =
HELLO 
HELLO 
HELLO 
HELLO (cb)
HELLO 
HELLO 
HELLO 
HELLO function(res)
HELLO 
HELLO res'
HELLO 
HELLO 
HELLO 
HELLO function(res)
HELLO 
HELLO 
HELLO 
HELLO function(res)
HELLO 
HELLO 
HELLO 
HELLO connectError);
HELLO connectError()
HELLO If
HELLO (connectionAttempts
HELLO failed,
HELLO 
HELLO 
HELLO 500);
HELLO 
HELLO 
HELLO attemptConnect()
HELLO 
HELLO 
HELLO host);
HELLO 
HELLO 
HELLO to
HELLO (isRemote)
HELLO 
HELLO else
HELLO function()
HELLO 
HELLO 
HELLO 
/home/cabox/workspace/desktop/ionic/iojs-3.3.1/lib/_debugger.js 232 // ???
/home/cabox/workspace/desktop/ionic/iojs-3.3.1/lib/_debugger.js 274 // TODO: We have a cache of handle's we've already seen in this.handles
/home/cabox/workspace/desktop/ionic/iojs-3.3.1/lib/_debugger.js 398 // TODO: from, to, bottom
/home/cabox/workspace/desktop/ionic/iojs-3.3.1/lib/_debugger.js 405 // TODO: from, to, bottom
